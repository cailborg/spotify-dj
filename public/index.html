<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Playlist DJ Merge</title>
    <script src="https://sdk.scdn.co/spotify-player.js"></script>
    <style>
        /* Same CSS as before - keeping it compact for space */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%); color: white; min-height: 100vh; padding: 20px; }
        .container { max-width: 1200px; margin: 0 auto; }
        h1 { text-align: center; margin-bottom: 30px; font-size: 2.5rem; text-shadow: 2px 2px 4px rgba(0,0,0,0.3); }
        .section { background: rgba(255, 255, 255, 0.1); border-radius: 15px; padding: 20px; margin-bottom: 20px; backdrop-filter: blur(10px); border: 1px solid rgba(255, 255, 255, 0.2); }
        .section h2 { margin-bottom: 15px; color: #ffd700; }
        button { background: linear-gradient(45deg, #ff6b6b, #ee5a24); color: white; border: none; padding: 12px 24px; border-radius: 25px; cursor: pointer; font-size: 16px; font-weight: bold; transition: all 0.3s ease; margin: 5px; }
        button:hover { transform: translateY(-2px); box-shadow: 0 5px 15px rgba(0,0,0,0.3); }
        button:disabled { background: #666; cursor: not-allowed; transform: none; }
        .playlist-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 15px; margin-top: 15px; }
        .playlist-item { background: rgba(255, 255, 255, 0.1); border-radius: 10px; padding: 15px; border: 2px solid transparent; cursor: pointer; transition: all 0.3s ease; }
        .playlist-item:hover { background: rgba(255, 255, 255, 0.2); }
        .playlist-item.selected { border-color: #ffd700; background: rgba(255, 215, 0, 0.2); }
        .track-list { max-height: 400px; overflow-y: auto; margin-top: 15px; }
        .track-item { background: rgba(255, 255, 255, 0.1); border-radius: 8px; padding: 12px; margin-bottom: 8px; display: flex; align-items: center; gap: 12px; cursor: grab; }
        .track-item:active { cursor: grabbing; }
        .track-item img { width: 50px; height: 50px; border-radius: 5px; }
        .track-info { flex: 1; }
        .track-title { font-weight: bold; margin-bottom: 4px; }
        .track-artist { color: #ccc; font-size: 14px; }
        .track-badges { display: flex; gap: 8px; }
        .badge { background: rgba(255, 215, 0, 0.3); padding: 4px 8px; border-radius: 12px; font-size: 12px; font-weight: bold; }
        .controls { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; margin-bottom: 20px; }
        .control-group { display: flex; align-items: center; gap: 8px; }
        select, input { background: rgba(255, 255, 255, 0.2); border: 1px solid rgba(255, 255, 255, 0.3); border-radius: 5px; padding: 8px 12px; color: white; font-size: 14px; }
        select option { background: #333; color: white; }
        .player { background: rgba(0, 0, 0, 0.5); border-radius: 15px; padding: 20px; text-align: center; }
        .current-track { display: flex; align-items: center; justify-content: center; gap: 20px; margin-bottom: 20px; }
        .current-track img { width: 80px; height: 80px; border-radius: 10px; }
        .track-progress { width: 100%; height: 6px; background: rgba(255, 255, 255, 0.3); border-radius: 3px; margin: 10px 0; overflow: hidden; }
        .progress-bar { height: 100%; background: linear-gradient(90deg, #ffd700, #ff6b6b); width: 0%; transition: width 0.5s ease; }
        .hidden { display: none; }
    </style>
</head>
<body>
    <div class="container">
        <h1>üéµ Playlist DJ Merge</h1>

        <!-- Authentication Section -->
        <div id="auth-section" class="section">
            <h2>Authentication</h2>
            <p>Connect your Spotify account to start mixing playlists:</p>
            <button onclick="login()">üéß Login with Spotify</button>
        </div>

        <!-- Playlist Selection -->
        <div id="playlist-section" class="section hidden">
            <h2>Select Playlists</h2>
            <button onclick="loadPlaylists()" id="load-playlists-btn">üìã Load My Playlists</button>
            <div id="playlist-grid" class="playlist-grid"></div>
            <button onclick="mergePlaylists()" id="merge-btn" class="hidden">üîÄ Merge Selected Playlists</button>
        </div>

        <!-- Track Ordering -->
        <div id="ordering-section" class="section hidden">
            <h2>Order Tracks</h2>
            <div class="controls">
                <div class="control-group">
                    <label>Sort Mode:</label>
                    <select id="sort-mode">
                        <option value="bpm-ascending">BPM ‚Üë (Ascending)</option>
                        <option value="bpm-descending">BPM ‚Üì (Descending)</option>
                        <option value="key-then-bpm">Key + BPM</option>
                        <option value="energy-arc">Energy Arc</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Target BPM:</label>
                    <input type="number" id="target-bpm" placeholder="120" min="60" max="200">
                </div>
                <div class="control-group">
                    <label>Max BPM Jump:</label>
                    <input type="number" id="max-jump" placeholder="20" min="1" max="50">
                </div>
                <button onclick="orderTracks()">üéØ Order Tracks</button>
            </div>
            <div id="track-list" class="track-list"></div>
        </div>

        <!-- Player Controls -->
        <div id="player-section" class="section hidden">
            <h2>DJ Player</h2>
            <div class="controls">
                <div class="control-group">
                    <label>Crossfade:</label>
                    <input type="range" id="crossfade" min="2" max="15" value="8">
                    <span id="crossfade-value">8s</span>
                </div>
                <button onclick="startSet()" id="start-set-btn">üöÄ Start DJ Set</button>
                <button onclick="stopSet()" id="stop-set-btn" class="hidden">‚èπÔ∏è Stop Set</button>
            </div>
            
            <div id="player" class="player">
                <div id="current-track" class="current-track">
                    <div>No track playing</div>
                </div>
                <div class="track-progress">
                    <div id="progress-bar" class="progress-bar"></div>
                </div>
                <div id="next-track">Next: None</div>
            </div>
        </div>
    </div>

    <script>
        // Global state
        let playlists = [];
        let selectedPlaylistIds = new Set();
        let mergedTracks = [];
        let orderedTracks = [];
        let currentTrackIndex = 0;
        let isPlaying = false;
        let spotifyPlayer = null;
        let fallbackPlayer = null;
        let crossfadeTime = 8000;
        let accessToken = null;
        let refreshToken = null;

        // Check for token in URL (from OAuth callback)
        function checkUrlForTokens() {
            const urlParams = new URLSearchParams(window.location.search);
            const token = urlParams.get('access_token');
            const refresh = urlParams.get('refresh_token');
            
            if (token) {
                accessToken = token;
                refreshToken = refresh;
                localStorage.setItem('spotify_access_token', token);
                localStorage.setItem('spotify_refresh_token', refresh);
                
                // Clean URL
                window.history.replaceState({}, document.title, window.location.pathname);
                
                // Show app
                document.getElementById('auth-section').classList.add('hidden');
                document.getElementById('playlist-section').classList.remove('hidden');
                return true;
            }
            
            // Check localStorage
            const storedToken = localStorage.getItem('spotify_access_token');
            if (storedToken) {
                accessToken = storedToken;
                refreshToken = localStorage.getItem('spotify_refresh_token');
                document.getElementById('auth-section').classList.add('hidden');
                document.getElementById('playlist-section').classList.remove('hidden');
                return true;
            }
            
            return false;
        }

        // Spotify Web Playback SDK
        window.onSpotifyWebPlaybackSDKReady = () => {
            console.log('Spotify Web Playback SDK is ready');
        };

        // Authentication
        function login() {
            window.location.href = '/login';
        }

        // API helper function
        async function spotifyAPI(endpoint, options = {}) {
            if (!accessToken) throw new Error('No access token');
            
            const response = await fetch(`/api/${endpoint}`, {
                ...options,
                headers: {
                    'Authorization': `Bearer ${accessToken}`,
                    'Content-Type': 'application/json',
                    ...options.headers
                }
            });
            
            if (!response.ok) {
                throw new Error(`API request failed: ${response.status}`);
            }
            
            return response.json();
        }

        // Load user playlists
        async function loadPlaylists() {
            const btn = document.getElementById('load-playlists-btn');
            const grid = document.getElementById('playlist-grid');
            
            btn.disabled = true;
            btn.textContent = 'Loading...';
            
            try {
                const data = await spotifyAPI('me/playlists?limit=50');
                
                playlists = data.items || [];
                grid.innerHTML = '';
                
                playlists.forEach(playlist => {
                    const item = document.createElement('div');
                    item.className = 'playlist-item';
                    item.onclick = () => togglePlaylist(playlist.id, item);
                    
                    item.innerHTML = `
                        <div class="track-title">${playlist.name}</div>
                        <div class="track-artist">${playlist.tracks.total} tracks ‚Ä¢ ${playlist.owner.display_name}</div>
                    `;
                    
                    grid.appendChild(item);
                });
                
                document.getElementById('merge-btn').classList.remove('hidden');
            } catch (error) {
                console.error('Failed to load playlists:', error);
                alert('Failed to load playlists');
            }
            
            btn.disabled = false;
            btn.textContent = 'üìã Load My Playlists';
        }

        function togglePlaylist(playlistId, element) {
            if (selectedPlaylistIds.has(playlistId)) {
                selectedPlaylistIds.delete(playlistId);
                element.classList.remove('selected');
            } else {
                selectedPlaylistIds.add(playlistId);
                element.classList.add('selected');
            }
        }

        // Merge selected playlists
        async function mergePlaylists() {
            if (selectedPlaylistIds.size === 0) {
                alert('Please select at least one playlist');
                return;
            }

            const btn = document.getElementById('merge-btn');
            btn.disabled = true;
            btn.textContent = 'Merging...';
            
            try {
                const allTracks = new Map();
                
                for (const playlistId of selectedPlaylistIds) {
                    let offset = 0;
                    let hasMore = true;
                    
                    while (hasMore) {
                        const data = await spotifyAPI(`playlists/${playlistId}/tracks?offset=${offset}&limit=100`);
                        
                        data.items.forEach(item => {
                            if (item.track && item.track.id && item.track.preview_url) {
                                allTracks.set(item.track.id, item.track);
                            }
                        });
                        
                        offset += 100;
                        hasMore = data.next !== null;
                    }
                }
                
                mergedTracks = Array.from(allTracks.values());
                
                if (mergedTracks.length === 0) {
                    alert('No tracks found or tracks missing preview URLs');
                    return;
                }
                
                // Get audio features
                await getAudioFeatures();
                
                document.getElementById('ordering-section').classList.remove('hidden');
                document.getElementById('player-section').classList.remove('hidden');
                
            } catch (error) {
                console.error('Failed to merge playlists:', error);
                alert('Failed to merge playlists');
            }
            
            btn.disabled = false;
            btn.textContent = 'üîÄ Merge Selected Playlists';
        }

        // Get audio features for tracks
        async function getAudioFeatures() {
            try {
                const trackIds = mergedTracks.map(track => track.id);
                const chunks = [];
                for (let i = 0; i < trackIds.length; i += 100) {
                    chunks.push(trackIds.slice(i, i + 100));
                }
                
                const allFeatures = [];
                for (const chunk of chunks) {
                    const data = await spotifyAPI(`audio-features?ids=${chunk.join(',')}`);
                    allFeatures.push(...data.audio_features.filter(f => f !== null));
                }
                
                window.audioFeatures = allFeatures;
                
            } catch (error) {
                console.error('Failed to get audio features:', error);
                window.audioFeatures = [];
            }
        }

        // Order tracks (client-side implementation)
        async function orderTracks() {
            const mode = document.getElementById('sort-mode').value;
            const targetBpm = parseInt(document.getElementById('target-bpm').value) || null;
            const maxJump = parseInt(document.getElementById('max-jump').value) || null;
            
            // Create feature lookup
            const featureMap = new Map(window.audioFeatures.map(f => [f.id, f]));
            
            // Add features to tracks
            const tracksWithFeatures = mergedTracks
                .map(track => ({
                    ...track,
                    features: featureMap.get(track.id)
                }))
                .filter(track => track.features);
            
            let ordered;
            
            switch (mode) {
                case 'bpm-ascending':
                    ordered = tracksWithFeatures.sort((a, b) => a.features.tempo - b.features.tempo);
                    break;
                case 'bpm-descending':
                    ordered = tracksWithFeatures.sort((a, b) => b.features.tempo - a.features.tempo);
                    break;
                case 'key-then-bpm':
                    ordered = tracksWithFeatures.sort((a, b) => {
                        if (a.features.key !== b.features.key) return a.features.key - b.features.key;
                        return a.features.tempo - b.features.tempo;
                    });
                    break;
                case 'energy-arc':
                    const sortedByEnergy = tracksWithFeatures.sort((a, b) => a.features.energy - b.features.energy);
                    const mid = Math.floor(sortedByEnergy.length / 2);
                    const ascending = sortedByEnergy.slice(0, mid);
                    const descending = sortedByEnergy.slice(mid).reverse();
                    ordered = [...ascending, ...descending];
                    break;
                default:
                    ordered = tracksWithFeatures;
            }
            
            // Apply BPM constraints if specified
            if (targetBpm && maxJump) {
                ordered = ordered.filter(track => 
                    Math.abs(track.features.tempo - targetBpm) <= maxJump
                );
            }
            
            orderedTracks = ordered;
            displayTrackList();
        }

        function displayTrackList() {
            const container = document.getElementById('track-list');
            container.innerHTML = '';
            
            orderedTracks.forEach((track, index) => {
                const item = document.createElement('div');
                item.className = 'track-item';
                item.draggable = true;
                
                const features = track.features || {};
                const bpm = Math.round(features.tempo || 0);
                const key = features.key !== undefined ? ['C','C‚ôØ','D','D‚ôØ','E','F','F‚ôØ','G','G‚ôØ','A','A‚ôØ','B'][features.key] : '?';
                const energy = Math.round((features.energy || 0) * 100);
                
                item.innerHTML = `
                    <img src="${track.album.images[0]?.url || ''}" alt="${track.name}">
                    <div class="track-info">
                        <div class="track-title">${track.name}</div>
                        <div class="track-artist">${track.artists.map(a => a.name).join(', ')}</div>
                    </div>
                    <div class="track-badges">
                        <span class="badge">${bpm} BPM</span>
                        <span class="badge">Key: ${key}</span>
                        <span class="badge">${energy}% Energy</span>
                    </div>
                `;
                
                // Drag and drop functionality
                item.addEventListener('dragstart', (e) => {
                    e.dataTransfer.setData('text/plain', index);
                });
                
                item.addEventListener('dragover', (e) => {
                    e.preventDefault();
                });
                
                item.addEventListener('drop', (e) => {
                    e.preventDefault();
                    const draggedIndex = parseInt(e.dataTransfer.getData('text/plain'));
                    const targetIndex = index;
                    
                    if (draggedIndex !== targetIndex) {
                        const draggedTrack = orderedTracks.splice(draggedIndex, 1)[0];
                        orderedTracks.splice(targetIndex, 0, draggedTrack);
                        displayTrackList();
                    }
                });
                
                container.appendChild(item);
            });
        }

        // Crossfade slider
        document.getElementById('crossfade').addEventListener('input', (e) => {
            crossfadeTime = parseInt(e.target.value) * 1000;
            document.getElementById('crossfade-value').textContent = e.target.value + 's';
        });

        // Simplified player for Netlify (preview mode only)
        async function startSet() {
            if (orderedTracks.length === 0) {
                alert('No tracks to play. Please merge and order playlists first.');
                return;
            }

            currentTrackIndex = 0;
            isPlaying = true;
            
            document.getElementById('start-set-btn').classList.add('hidden');
            document.getElementById('stop-set-btn').classList.remove('hidden');
            
            initFallbackPlayer();
            playCurrentTrack();
        }

        function initFallbackPlayer() {
            fallbackPlayer = {
                audio1: new Audio(),
                audio2: new Audio(),
                current: 'audio1',
                gainNode1: null,
                gainNode2: null,
                audioContext: null
            };

            try {
                fallbackPlayer.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                const source1 = fallbackPlayer.audioContext.createMediaElementSource(fallbackPlayer.audio1);
                const source2 = fallbackPlayer.audioContext.createMediaElementSource(fallbackPlayer.audio2);
                
                fallbackPlayer.gainNode1 = fallbackPlayer.audioContext.createGain();
                fallbackPlayer.gainNode2 = fallbackPlayer.audioContext.createGain();
                
                source1.connect(fallbackPlayer.gainNode1);
                source2.connect(fallbackPlayer.gainNode2);
                
                fallbackPlayer.gainNode1.connect(fallbackPlayer.audioContext.destination);
                fallbackPlayer.gainNode2.connect(fallbackPlayer.audioContext.destination);
                
                fallbackPlayer.gainNode2.gain.value = 0;
            } catch (error) {
                console.error('Web Audio API not supported:', error);
            }
        }

        function playCurrentTrack() {
            if (currentTrackIndex >= orderedTracks.length) {
                stopSet();
                return;
            }

            const track = orderedTracks[currentTrackIndex];
            playFallbackTrack(track);
            updateCurrentTrackDisplay(track);
            scheduleNextTrack();
        }

        function playFallbackTrack(track) {
            if (!track.preview_url) {
                console.warn('No preview available for track:', track.name);
                nextTrack();
                return;
            }

            const currentAudio = fallbackPlayer[fallbackPlayer.current];
            currentAudio.src = track.preview_url;
            currentAudio.play();
            
            currentAudio.addEventListener('timeupdate', updateFallbackProgress);
            currentAudio.addEventListener('ended', nextTrack);
        }

        function updateFallbackProgress() {
            const currentAudio = fallbackPlayer[fallbackPlayer.current];
            const progress = (currentAudio.currentTime / 30) * 100;
            document.getElementById('progress-bar').style.width = progress + '%';
        }

        function updateCurrentTrackDisplay(track) {
            const container = document.getElementById('current-track');
            container.innerHTML = `
                <img src="${track.album.images[0]?.url || ''}" alt="${track.name}">
                <div>
                    <div class="track-title">${track.name}</div>
                    <div class="track-artist">${track.artists.map(a => a.name).join(', ')}</div>
                </div>
            `;
            
            const nextTrack = orderedTracks[currentTrackIndex + 1];
            document.getElementById('next-track').textContent = nextTrack 
                ? `Next: ${nextTrack.name} - ${nextTrack.artists.map(a => a.name).join(', ')}`
                : 'Next: End of set';
        }

        function scheduleNextTrack() {
            const duration = 30000; // 30s for previews
            const nextTrackTime = Math.max(duration - crossfadeTime, 5000);
            
            setTimeout(() => {
                if (isPlaying) {
                    startCrossfade();
                }
            }, nextTrackTime);
        }

        function startCrossfade() {
            if (fallbackPlayer && fallbackPlayer.audioContext) {
                const nextIndex = currentTrackIndex + 1;
                if (nextIndex >= orderedTracks.length) {
                    stopSet();
                    return;
                }
                
                const nextTrack = orderedTracks[nextIndex];
                const nextAudio = fallbackPlayer.current === 'audio1' ? 'audio2' : 'audio1';
                const nextAudioElement = fallbackPlayer[nextAudio];
                const nextGainNode = fallbackPlayer.current === 'audio1' ? fallbackPlayer.gainNode2 : fallbackPlayer.gainNode1;
                const currentGainNode = fallbackPlayer.current === 'audio1' ? fallbackPlayer.gainNode1 : fallbackPlayer.gainNode2;
                
                if (nextTrack.preview_url) {
                    nextAudioElement.src = nextTrack.preview_url;
                    nextAudioElement.play();
                    
                    // Crossfade animation
                    const fadeSteps = 50;
                    const stepTime = crossfadeTime / fadeSteps;
                    let step = 0;
                    
                    const fadeInterval = setInterval(() => {
                        const progress = step / fadeSteps;
                        currentGainNode.gain.value = 1 - progress;
                        nextGainNode.gain.value = progress;
                        
                        step++;
                        if (step >= fadeSteps) {
                            clearInterval(fadeInterval);
                            fallbackPlayer.current = nextAudio;
                            currentTrackIndex = nextIndex;
                            updateCurrentTrackDisplay(nextTrack);
                            scheduleNextTrack();
                        }
                    }, stepTime);
                } else {
                    nextTrack();
                }
            } else {
                nextTrack();
            }
        }

        function nextTrack() {
            currentTrackIndex++;
            if (isPlaying) {
                playCurrentTrack();
            }
        }

        function stopSet() {
            isPlaying = false;
            currentTrackIndex = 0;
            
            if (fallbackPlayer) {
                fallbackPlayer.audio1.pause();
                fallbackPlayer.audio2.pause();
            }
            
            document.getElementById('start-set-btn').classList.remove('hidden');
            document.getElementById('stop-set-btn').classList.add('hidden');
            document.getElementById('progress-bar').style.width = '0%';
            document.getElementById('current-track').innerHTML = '<div>No track playing</div>';
            document.getElementById('next-track').textContent = 'Next: None';
        }

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', () => {
            checkUrlForTokens();
        });
    </script>
</body>
</html>